# üß¨ Process Hollowing with AES-Encrypted Shellcode and Partial Indirect Syscalls

This project demonstrates a stealthy process injection technique known as **Process Hollowing**, enhanced with several evasion mechanisms designed to bypass modern EDR and antivirus solutions in lab or offensive environments.

---
### üîç Note on Indirect Syscalls

This project demonstrates a hybrid implementation: only the `NtAllocateVirtualMemory` syscall is executed indirectly through a memory stub, while the rest (`NtWriteVirtualMemory`, `NtProtectVirtualMemory`, `NtCreateThreadEx`) are still invoked via direct P/Invoke. 

In fully advanced scenarios, it's recommended to replace all system calls with indirect stubs to completely bypass userland hooks in monitored environments.


---

### üîí Key Features:

- **AES-encrypted shellcode**: Shellcode is encrypted using AES-256 and decrypted in memory at runtime.
- **Indirect syscalls**: System calls are executed through manually copied syscall stubs to evade userland API hooks.
- **PPID Spoofing**: The spawned process impersonates a trusted parent (e.g., explorer.exe) to evade behavior-based detection mechanisms.

### ‚ö†Ô∏è Remember to check the IP in the files!!
---

## ‚öôÔ∏è How It Works

### 1. PPID Spoofing

The injector uses STARTUPINFOEX in conjunction with UpdateProcThreadAttribute to spoof the parent process ID. This makes the newly created process (svchost.exe) appear as if it was spawned by a legitimate parent such as explorer.exe, reducing behavioral red flags.

### 2. AES Shellcode Decryption

- The shellcode is encrypted using AES in CBC mode with a randomly generated 256-bit key and 128-bit IV.
- These values are generated via a Python script and embedded into the injector.
- At runtime, the encrypted payload is decrypted using the System.Security.Cryptography.Aes library.

### 3. Indirect Syscalls

- The injector locates the syscall stub for NtAllocateVirtualMemory within ntdll.dll.
- It copies the stub into a RWX memory region and invokes it through a delegate, bypassing userland hooks often placed by security tools.

### 4. Process Hollowing

- A suspended instance of svchost.exe is created with the spoofed parent process.
- Decrypted shellcode is allocated and written into the memory of the suspended process.
- The memory protection is updated to executable using NtProtectVirtualMemory.
- A remote thread is launched using NtCreateThreadEx to execute the injected shellcode.

---

## üîê AES Encryption Script

A companion Python script (Aes_encryption.py) is used to encrypt a shellcode.bin file using AES-256-CBC. The script outputs the following C# byte arrays:

- encryptedShellcode
- aesKey
- aesIV

These arrays are copy-pasted into the C# injector before compilation.

---

## ‚ö†Ô∏è Avoiding Detection with Custom Payloads

Payloads generated by tools like msfvenom are highly signatured and commonly flagged by antivirus and EDR solutions.

To avoid this, a **custom C# loader** (Executable_Generator.cs) is used. This loader launches PowerShell to download and execute two external scripts from a remote HTTP server:

- amsi.txt: An AMSI bypass script
- shell.ps1: A PowerShell reverse shell payload

---

## üõ†Ô∏è Generating AES-Encrypted Shellcode with Donut

Follow these steps to produce your final shellcode payload:

### 1. Write the custom C# payload loader

Create a file like Executable_Generator.cs that executes a PowerShell command to download and run the AMSI bypass and reverse shell from a remote server.

### 2. Compile the loader in Visual Studio

### 3. Generate shellcode with Donut

bash
donut.exe -i Executable_Generator.exe -a 2 -f 1 -o shellcode.bin


### 4. Encrypt the shellcode

Use the provided AES Python script:

bash
python3 Aes_encryption.py

This will output the AES-encrypted payload and corresponding key/IV in C# format. Copy the output and paste it into the injector.


### 5. Setup http server and listener

## üñ•Ô∏è Hosting the Reverse Shell Payload

The PowerShell reverse shell should be saved as `shell.ps1`.

Then serve the file using Python‚Äôs built-in HTTP server:

```bash
python3 -m http.server 80
```

---

## üì° Setting Up the Listener

To catch the reverse shell, start a listener using `netcat` and `rlwrap` for a better terminal experience:

```bash
rlwrap -cAr nc -lnvp 443
```

---

## ‚úÖ Final Notes

This project combines multiple stealth techniques to evade AV/EDR solutions:
- AES encryption
- PPID spoofing
- Indirect syscalls
- Custom shellcode loader

While no method guarantees 100% evasion, this layered approach drastically reduces detection probability and demonstrates techniques relevant for red teaming and advanced adversary simulation.
